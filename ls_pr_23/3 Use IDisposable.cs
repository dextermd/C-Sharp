namespace _3_Use_IDisposable
{
    internal class Program
    {
        static void Main(string[] args)
        {

            //Person obj = new Person(444);
            //if (obj is IDisposable)
            //{
            //    obj.Dispose();
            //}


            //Person? obj2 = null;
            //try
            //{
            //    obj2 = new Person(555);
            //}
            //finally
            //{
            //    if (obj2 is IDisposable)
            //        obj2?.Dispose();
            //}

            //---------------------------------------------------------
            using (Person obj3 = new Person(555))
            {
                Console.WriteLine(obj3);
            }

            Console.Read();
        }
        public static void Test()
        {
            using (Person tom = new Person(111))
            {
                // переменная tom доступна только в блоке using
                // некоторые действия с объектом Person
                Console.WriteLine($"Name: {tom.Id}");
            }
            Console.WriteLine("Конец метода Test");
        }
    }
    // Данный класс реализует интерейс IDisposable
    class Person : IDisposable
    {
        public int Id { get; set; }

        public Person(int id)
        {
            this.Id = id;
        }

        // Реализуем метод Dispose()
        // После окончания работы с объектом пользователь
        // объекта должен вызывать этот метод
        public void Dispose()
        {
            // Очистить неуправляемые ресурсы...
            // Освободить другие содержащиеся внутри освобождаемые объекты.
            // Только для целей тестирования.
            Console.WriteLine($"Высвобождение объекта: {Id}");
        }
    }
 
}

/*
 Различия в поведении могут возникнуть из-за особенностей среды выполнения и фреймворка. 
В .NET Core и .NET Framework есть некоторые различия, включая способы, 
которыми они обрабатывают финализацию объектов.

В .NET Framework используется механизм CLR (Common Language Runtime), 
который может обеспечивать более предсказуемое поведение финализации объектов.

В .NET Core, который является более новой и кроссплатформенной версией .NET, 
реализация CLR может быть менее предсказуемой из-за адаптации к 
различным операционным системам и архитектурам.

Также, стоит уточнить, что важно избегать зависимости от конкретного поведения 
сборщика мусора в вашем коде, поскольку это может изменяться между версиями 
фреймворка или даже в рамках одной и той же версии в разных условиях выполнения.

Если вам нужно точное управление жизненным циклом объекта, 
лучше использовать интерфейс IDisposable и метод Dispose 
для освобождения ресурсов в явном порядке. 

Финализаторы (~Finalize) в C# следует использовать 
с осторожностью из-за неопределенности времени выполнения.
 
 */
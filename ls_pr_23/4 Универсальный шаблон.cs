namespace _4_Кобинированный_подход
{
    internal class Program
    {
        static void Main(string[] args)
        {
            using (SomeClass someClass = new SomeClass() { Id = 111 })
            {
                Console.WriteLine(someClass.Id);
            };
            
            Console.Read();
        }
    }
    public class SomeClass : IDisposable
    {
        public int Id { get; set; }
        // Использовался ли метод Dispose
        private bool disposed = false;

        // реализация интерфейса IDisposable.
        public void Dispose()
        {
            // Вызов вспомогательного мтеода
            //true - очистку запустил пользователь объекта
            Dispose(true);
            // подавляем финализацию
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool check)// Вспомогательный метод
        {
            // Удостовериться, не выполнялось ли уже освобождение
            if (disposed) return;
            if (check)
            {
                // Освобождаем управляемые ресурсы
                Console.WriteLine($"Высвобождение объекта: {Id}");
            }
            // освобождаем неуправляемые ресурсы
            Console.WriteLine("Освобождение неуправляемых ресурсов");
            disposed = true;
        }

        // Деструктор
        ~SomeClass()
        {
            //false указывает на то, что очистку
            //инициировал сборщик мусора
            Dispose(false);
        }
    }
}

/*
 Логика очистки реализуется перегруженной версией метода Dispose(bool check). 
 Если параметр check имеет значение true, то данный метод вызывается из публичного метода Dispose, 
 если false - то из деструктора.

 При вызове деструктора в качестве параметра check передается значение false, 
 чтобы избежать очистки управляемых ресурсов, 
 так как мы не можем быть уверенными в их состоянии, 
 что они до сих пор находятся в памяти. 
 И в этом случае остается полагаться на деструкторы этих ресурсов. 
 
 Ну и в обоих случаях освобождаются неуправляемые ресурсы.

 Еще один важный момент - вызов в методе Dispose метода GC.SuppressFinalize(this). 
 GC.SuppressFinalize не позволяет системе выполнить метод Finalize для данного объекта. 
 Если же в классе деструктор не определен, то вызов этого метода не будет иметь никакого эффекта.

 Таким образом, даже если разработчик не использует в программе метод Dispose, 
 все равно произойдет очистка и освобождение ресурсов.
 
 */